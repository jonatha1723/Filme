<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Builder 3D - Physics Fixes</title>
    
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* --- ESTILOS GERAIS --- */
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* LOBBY */
        #loader { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(180deg, #1a237e, #4da6ff); color: white; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 99;
        }
        .title { 
            font-size: 40px; font-weight: 900; margin-bottom: 20px; 
            text-shadow: 4px 4px 0px #000; letter-spacing: 2px; text-align: center;
        }
        .room-card {
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px;
            display: flex; flex-direction: column; gap: 10px; width: 300px;
            border: 4px solid rgba(255,255,255,0.2); box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        .room-input {
            padding: 12px; border-radius: 4px; border: 2px solid #555; text-align: center; 
            font-family: inherit; font-weight: bold; background: rgba(255,255,255,0.9); font-size: 16px;
        }
        .room-btn {
            padding: 15px; font-size: 18px; 
            background: #7cb342; border: 2px solid #fff; border-radius: 4px; 
            font-weight: bold; cursor: pointer; color: white;
            text-transform: uppercase; transition: transform 0.1s;
            box-shadow: 0 4px 0 #33691e;
        }
        .room-btn:active { transform: translateY(4px); box-shadow: none; }
        .room-btn:disabled { background: #555; box-shadow: none; cursor: not-allowed; }
        #debug-log { margin-top: 15px; font-size: 12px; color: #ffeb3b; text-align: center; max-width: 90%; }

        /* HUD JOGO */
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            transform: translate(-50%, -50%); pointer-events: none; opacity: 0.8;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; box-shadow: 0 0 2px rgba(0,0,0,0.5); }
        #crosshair::before { top: 10px; left: 0; width: 24px; height: 4px; }
        #crosshair::after { top: 0; left: 10px; width: 4px; height: 24px; }

        /* BARRA DE MINERA√á√ÉO */
        #mining-bar-container {
            position: absolute; top: 55%; left: 50%; transform: translateX(-50%);
            width: 200px; height: 16px; background: #333; border: 2px solid white;
            display: none; box-shadow: 0 4px 0 rgba(0,0,0,0.4);
        }
        #mining-bar { width: 0%; height: 100%; background: #76ff03; transition: width 0.05s linear; }

        /* CHAT */
        #chat-btn {
            position: absolute; top: 10px; left: 10px; width: 44px; height: 44px;
            background: rgba(0,0,0,0.5); border-radius: 4px; border: 2px solid white;
            color: white; font-size: 24px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 30;
        }
        #chat-overlay {
            position: absolute; top: 60px; left: 10px; width: 300px; display: none; pointer-events: none;
        }
        #chat-messages {
            max-height: 150px; overflow-y: hidden; display: flex; flex-direction: column; gap: 4px;
            margin-bottom: 5px; mask-image: linear-gradient(to bottom, transparent, black 10%);
        }
        .chat-msg { background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; color: white; font-size: 14px; text-shadow: 1px 1px 0 #000; align-self: flex-start; }
        #chat-input-wrapper { display: flex; pointer-events: auto; gap: 5px; }
        #chat-input { flex: 1; background: rgba(0,0,0,0.7); border: 2px solid white; color: white; padding: 8px; font-family: inherit; }
        
        /* MENU (INVENT√ÅRIO) */
        #menu-btn {
            position: absolute; top: 10px; right: 10px; width: 44px; height: 44px;
            background: rgba(0,0,0,0.5); border-radius: 4px; border: 2px solid white;
            color: white; font-size: 28px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; z-index: 40;
        }
        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; z-index: 100; pointer-events: auto;
            justify-content: center; align-items: center;
        }
        #modal-content {
            width: 90%; max-width: 500px; background: #c6c6c6; color: #333;
            border: 4px solid #fff; outline: 4px solid #333; padding: 15px;
            display: flex; flex-direction: column; gap: 15px;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.5);
        }
        .tabs { display: flex; gap: 5px; margin-bottom: 5px; }
        .tab-btn {
            flex: 1; padding: 12px; background: #8b8b8b; border: 2px solid #555; color: white;
            cursor: pointer; font-weight: bold; font-size: 16px; text-shadow: 1px 1px 0 #000;
        }
        .tab-btn.active { background: #c6c6c6; color: #333; border-color: #fff; text-shadow: none; }
        #inv-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;
            max-height: 250px; overflow-y: auto; padding: 8px; background: #8b8b8b; border: 2px solid #555;
        }
        .inv-item {
            aspect-ratio: 1; border: 2px solid #333;
            cursor: pointer; position: relative; background-size: cover; box-shadow: inset 2px 2px 0 rgba(255,255,255,0.2), inset -2px -2px 0 rgba(0,0,0,0.2);
        }
        .inv-item:hover { border-color: white; transform: scale(1.05); }
        .inv-item.selected { border: 4px solid #fff000; z-index: 2; }
        
        /* CRIADOR */
        #creator-form { display: none; flex-direction: column; gap: 10px; background: #8b8b8b; padding: 10px; border: 2px solid #555; }
        .form-group { display: flex; flex-direction: column; gap: 4px; }
        .form-group label { font-size: 14px; color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        .form-input { padding: 8px; border: 2px solid #333; background: #555; color: white; font-size: 14px; width: 100%; box-sizing: border-box;}
        #btn-create {
            padding: 15px; background: #7cb342; color: white; border: 2px solid #33691e;
            font-weight: bold; cursor: pointer; margin-top: 5px; font-size: 16px; text-shadow: 1px 1px 0 #000;
        }
        #close-modal { margin-top: 5px; background: #d32f2f; padding: 10px; border: 2px solid #b71c1c; color: white; cursor: pointer; width: 100%; font-weight: bold;}

        /* CONTROLES */
        #stick-zone { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(0,0,0,0.2); border-radius: 50%; border: 4px solid rgba(255,255,255,0.4); pointer-events: auto; }
        #stick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        #look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 70%; z-index: 25; pointer-events: auto; }

        /* HOTBAR */
        #hotbar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 6px; pointer-events: auto;
            background: rgba(0, 0, 0, 0.6); padding: 6px; border-radius: 4px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .slot {
            width: 48px; height: 48px; background: rgba(100,100,100,0.5); 
            border: 2px solid #888; cursor: pointer; position: relative;
            display: flex; justify-content: center; align-items: center; 
            font-size: 24px; color: white;
        }
        .slot.active { border: 4px solid white; transform: scale(1.1); z-index: 10; background: rgba(150,150,150,0.8); }
        .slot-pickaxe { font-size: 24px; }

        /* A√á√ïES */
        #btn-action { 
            position: absolute; right: 30px; bottom: 120px; width: 80px; height: 80px; 
            background: #e0e0e0; border-radius: 12px; color: #333; font-size: 32px; 
            display: flex; justify-content: center; align-items: center; pointer-events: auto; 
            border-bottom: 6px solid #9e9e9e; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            user-select: none; z-index: 50; transition: transform 0.1s;
        }
        #btn-action:active { transform: translateY(6px); border-bottom: 0; box-shadow: none; }
        
        #btn-jump { 
            position: absolute; right: 130px; bottom: 40px; width: 70px; height: 70px; 
            background: rgba(0,0,0,0.4); border-radius: 12px; color: white; font-size: 28px; 
            display: flex; justify-content: center; align-items: center; pointer-events: auto; 
            border: 2px solid rgba(255,255,255,0.5); z-index: 50;
        }
        #btn-jump:active { background: rgba(255,255,255,0.3); }

        /* Bubbles */
        .player-bubble {
            position: absolute; background: rgba(0,0,0,0.6); color: white; padding: 6px 12px;
            border-radius: 4px; font-size: 14px; pointer-events: none; white-space: nowrap;
            transform: translate(-50%, -100%); margin-top: -35px; display: none; text-align: center;
            border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.5); font-weight: bold;
        }
        .player-name { font-size: 10px; color: #ffd700; display: block; margin-bottom: 2px; text-shadow: 1px 1px 0 #000; }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="loader">
        <div class="title">BUILDER 3D<br>GLOBAL WORLD</div>
        <div class="room-card">
            <input type="text" id="username" class="room-input" placeholder="Seu Nickname" maxlength="10">
            <input type="text" id="room-id" class="room-input" value="SERVER_GLOBAL" readonly style="background: rgba(0,0,0,0.3); color: #aaa; cursor: not-allowed;">
            <button id="btn-join" class="room-btn" onclick="app.joinGame()">ENTRAR NO MUNDO</button>
        </div>
        <div id="debug-log">Pronto.</div>
    </div>

    <!-- MODAL (INVENT√ÅRIO / CRIADOR) -->
    <div id="modal-overlay">
        <div id="modal-content">
            <div class="tabs">
                <button class="tab-btn active" onclick="app.switchTab('inv')">BLOCOS</button>
                <button class="tab-btn" onclick="app.switchTab('creator')">CRIAR NOVO</button>
            </div>
            <div id="tab-inv"><div id="inv-grid"></div></div>
            <div id="tab-creator">
                <div id="creator-form">
                    <div class="form-group"><label>Nome</label><input type="text" id="new-name" class="form-input" placeholder="Ex: Bloco Ouro"></div>
                    <div class="form-group"><label>Cor</label><input type="color" id="new-color" class="form-input" value="#ff0000" style="height:40px;"></div>
                    <div class="form-group">
                        <label>Script do Bloco (JS)</label>
                        <textarea id="new-script" class="form-input" style="height: 80px; font-family: monospace; font-size: 11px;" placeholder="Ex: this.onTick = () => { this.mesh.rotation.y += 0.05; }"></textarea>
                    </div>
                    <div class="form-group"><label>Efeito</label>
                        <div style="display:flex; gap:5px; margin-top:5px;">
                            <button onclick="app.setEffect('glow')" style="flex:1;background:#555;color:white;border:1px solid #333;padding:5px;">Luz</button>
                            <button onclick="app.setEffect('glass')" style="flex:1;background:#555;color:white;border:1px solid #333;padding:5px;">Vidro</button>
                            <button onclick="app.setEffect('bounce')" style="flex:1;background:#555;color:white;border:1px solid #333;padding:5px;">Pulo</button>
                        </div>
                        <input type="hidden" id="new-props" value="{}">
                    </div>
                    <button id="btn-create" onclick="app.createCustomBlock()">CRIAR</button>
                </div>
            </div>
            <button id="close-modal" onclick="app.toggleMenu()">VOLTAR</button>
        </div>
    </div>

    <!-- UI JOGO -->
    <div id="game-ui">
        <div id="crosshair"></div>
        <div id="mining-bar-container"><div id="mining-bar"></div></div>
        <div id="chat-btn" onclick="app.toggleChat()">üí¨</div>
        <div id="menu-btn" onclick="app.toggleMenu()">‚ò∞</div>
        <div id="chat-overlay">
            <div id="chat-messages"></div>
            <div id="chat-input-wrapper">
                <input id="chat-input" placeholder="Msg..." onkeydown="if(event.key==='Enter') app.sendChat()">
                <button onclick="app.sendChat()" style="background:#7cb342;color:white;border:2px solid white;font-weight:bold;">></button>
            </div>
        </div>
        <div id="bubbles-container"></div>
        <div id="stick-zone"><div id="stick-knob"></div></div>
        <div id="look-zone"></div>
        <div id="hotbar">
            <div class="slot slot-pickaxe" onclick="app.selectTool('mine')">‚õèÔ∏è</div>
            <div id="build-slot" class="slot active" style="background-color: #8d6e63;" onclick="app.toggleMenu()"></div>
        </div>
        <div id="btn-action">üî®</div>
        <div id="btn-jump">‚ñ≤</div>
    </div>

    <script>
        // CONFIGURA√á√ÉO SUPABASE
        const SB_URL = 'https://uonfrjjuhnrjewxzmuqc.supabase.co';
        const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVvbmZyamp1aG5yamV3eHptdXFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MDU4NzUsImV4cCI6MjA4NjA4MTg3NX0.OXVl1AXeM1-mYION0Y3_oRWVyLvY6CJsR4Sz9p7Ghqo';
        
        let supabase;
        try { supabase = window.supabase.createClient(SB_URL, SB_KEY, { auth: { persistSession: false, autoRefreshToken: false } }); } 
        catch(e) { console.error("Erro Supabase:", e); }

        let BLOCK_REGISTRY = {
            '1': { name: 'Madeira', color: '#8d6e63', props: {} },
            '2': { name: 'Pedra', color: '#9e9e9e', props: {} },
            '3': { name: 'Tijolo', color: '#d32f2f', props: {} },
            '4': { name: 'Ferro', color: '#cfd8dc', props: {} },
            '5': { name: 'Vidro', color: '#81d4fa', props: { transparent: true, opacity: 0.5 } },
            '6': { name: 'Grama', color: '#76ff03', props: {} },
            '7': { name: 'Terra', color: '#5d4037', props: {} },
            '8': { name: 'Ouro', color: '#ffeb3b', props: { glow: true } }
        };
        let MATERIALS = {}; 
        let channel = null;
        let scene, camera, renderer, clock;
        let localPlayer, ghostMesh, myMeshBody;
        let remotePlayers = {}; 
        let blockObjects = []; 
        let blocksData = {}; 
        let currentTool = 'build'; 
        let selectedBlockId = '1';
        let miningInterval = null;
        let miningProgress = 0;
        let lastBroadcast = 0;
        let isTouchingAction = false;
        
        const raycaster = new THREE.Raycaster();
        raycaster.far = 8; 

        const state = {
            id: 'p_' + Math.random().toString(36).substr(2, 9),
            name: "Player",
            room: "SERVER_GLOBAL",
            moveX: 0, moveY: 0, rotX: 0, rotY: 0,
            velY: 0, onGround: false
        };

        // --- FUN√á√ÉO AUXILIAR PARA SCRIPT ---
        function executeBlockScript(blockObj, scriptText) {
            if (!scriptText || scriptText.trim() === "") return;
            try {
                // O 'this' dentro do script ser√° o objeto do bloco
                const scriptFunc = new Function(scriptText);
                scriptFunc.call(blockObj); 
                
                // Se o script definiu um onPlace, executa agora
                if (blockObj.onPlace) blockObj.onPlace();
            } catch (e) {
                console.error("Erro no script do bloco:", e);
            }
        }

        window.app = {
            joinGame() {
                const userVal = document.getElementById('username').value.trim();
                if(!userVal) return alert("Digite Nick!");
                state.name = userVal;
                document.getElementById('btn-join').disabled = true;
                document.getElementById('btn-join').innerText = "CONECTANDO...";
                initMaterials();
                init3D();
                setupInputs();
                setupNetwork();
                this.updateInventoryUI();
            },
            selectTool(tool) {
                currentTool = tool;
                const btn = document.getElementById('btn-action');
                const pickSlot = document.querySelector('.slot-pickaxe');
                const buildSlot = document.getElementById('build-slot');
                if(tool === 'mine') {
                    btn.innerText = "‚õèÔ∏è"; btn.style.background = "#d32f2f";
                    ghostMesh.visible = false;
                    pickSlot.classList.add('active'); buildSlot.classList.remove('active');
                } else {
                    btn.innerText = ""; btn.style.background = "#e0e0e0 url('https://img.icons8.com/material-rounded/48/000000/sugar-cube.png') center no-repeat"; btn.style.backgroundSize = "50%";
                    ghostMesh.visible = true; updateGhostMaterial();
                    pickSlot.classList.remove('active'); buildSlot.classList.add('active');
                }
            },
            toggleMenu() {
                const el = document.getElementById('modal-overlay');
                el.style.display = el.style.display === 'flex' ? 'none' : 'flex';
                state.moveX = 0; state.moveY = 0;
                document.getElementById('stick-knob').style.transform = `translate(-50%, -50%)`;
                if(el.style.display === 'flex') this.switchTab('inv');
            },
            switchTab(tab) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-inv').style.display = 'none';
                document.getElementById('tab-creator').style.display = 'none';
                if(tab === 'inv') {
                    document.getElementById('tab-inv').style.display = 'block';
                    document.querySelector('.tab-btn:first-child').classList.add('active');
                    this.updateInventoryUI();
                } else {
                    document.getElementById('tab-creator').style.display = 'flex';
                    document.querySelector('.tab-btn:last-child').classList.add('active');
                }
            },
            updateInventoryUI() {
                const grid = document.getElementById('inv-grid');
                grid.innerHTML = '';
                for(let id in BLOCK_REGISTRY) {
                    const b = BLOCK_REGISTRY[id];
                    const div = document.createElement('div');
                    div.className = 'inv-item';
                    div.style.backgroundColor = b.color;
                    div.title = b.name;
                    if(id === selectedBlockId) div.classList.add('selected');
                    div.onclick = () => { selectedBlockId = id; document.getElementById('build-slot').style.backgroundColor = b.color; app.selectTool('build'); app.toggleMenu(); };
                    grid.appendChild(div);
                }
            },
            setEffect(type) {
                const propsInput = document.getElementById('new-props');
                let props = {};
                if(type === 'glow') props = { glow: true };
                if(type === 'glass') props = { transparent: true, opacity: 0.5 };
                if(type === 'bounce') props = { bounciness: 1.5 };
                propsInput.value = JSON.stringify(props);
                alert("Efeito: " + type);
            },
            createCustomBlock() {
                const name = document.getElementById('new-name').value || 'Bloco Custom';
                const color = document.getElementById('new-color').value;
                const script = document.getElementById('new-script').value;
                const propsVal = document.getElementById('new-props').value;
                let props = {};
                try { props = JSON.parse(propsVal); } catch(e){}
                const newId = 'c_' + Date.now().toString(36);
                const newDef = { name, color, props, script };
                BLOCK_REGISTRY[newId] = newDef;
                createMaterial(newId, newDef);
                selectedBlockId = newId;
                document.getElementById('build-slot').style.backgroundColor = color;
                if(channel) channel.send({ type: 'broadcast', event: 'new_def', payload: { id: newId, def: newDef } });
                app.toggleMenu(); app.selectTool('build');
            },
            toggleChat() {
                const el = document.getElementById('chat-overlay');
                const inp = document.getElementById('chat-input');
                el.style.display = el.style.display === 'block' ? 'none' : 'block';
                if(el.style.display === 'block') inp.focus(); else inp.blur();
            },
            sendChat() {
                const inp = document.getElementById('chat-input');
                const txt = inp.value.trim();
                if(txt && channel) {
                    channel.send({ type: 'broadcast', event: 'chat', payload: { id: state.id, name: state.name, msg: txt } });
                    app.addChatMessage(state.name, txt);
                    showBubble(localPlayer, txt, state.name);
                    inp.value = '';
                }
            },
            addChatMessage(name, msg) {
                const div = document.createElement('div');
                div.className = 'chat-msg';
                div.innerHTML = `<b style="color:#ffd700">${name}:</b> ${msg}`;
                const container = document.getElementById('chat-messages');
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
                setTimeout(() => div.remove(), 10000);
            }
        };

        function initMaterials() {
            for(let id in BLOCK_REGISTRY) createMaterial(id, BLOCK_REGISTRY[id]);
        }

        function createMaterial(id, def) {
            const params = { color: def.color, roughness: 0.8, metalness: 0.1 };
            if (def.props.transparent) { params.transparent = true; params.opacity = def.props.opacity || 0.6; }
            if (def.props.glow) { params.emissive = def.color; params.emissiveIntensity = 0.5; }
            MATERIALS[id] = new THREE.MeshStandardMaterial(params);
        }

        // --- TEXTURA DO CH√ÉO ORIGINAL ---
        function createFloorTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#558b2f'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#33691e'; ctx.fillRect(0,0,32,32); ctx.fillRect(32,32,32,32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.NearestFilter;
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(200, 200); return tex;
        }

        function createPlayerMesh(isLocal) {
            const mesh = new THREE.Group();
            if(isLocal) return mesh; 

            const matSkin = new THREE.MeshStandardMaterial({ color: 0xe0c09f });
            const matShirt = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const matPants = new THREE.MeshStandardMaterial({ color: 0x3333AA });

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
            head.position.y = 1.5; head.castShadow = true;
            mesh.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.75, 0.25), matShirt);
            body.position.y = 0.875; body.castShadow = true;
            mesh.add(body);

            const armGeo = new THREE.BoxGeometry(0.2, 0.75, 0.2);
            const legGeo = new THREE.BoxGeometry(0.24, 0.75, 0.24);

            const leftArmG = new THREE.Group(); leftArmG.position.set(-0.35, 1.25, 0);
            const leftArm = new THREE.Mesh(armGeo, matSkin); leftArm.position.y = -0.25;
            leftArmG.add(leftArm); mesh.add(leftArmG);

            const rightArmG = new THREE.Group(); rightArmG.position.set(0.35, 1.25, 0);
            const rightArm = new THREE.Mesh(armGeo, matSkin); rightArm.position.y = -0.25;
            rightArmG.add(rightArm); mesh.add(rightArmG);

            const leftLegG = new THREE.Group(); leftLegG.position.set(-0.12, 0.5, 0);
            const leftLeg = new THREE.Mesh(legGeo, matPants); leftLeg.position.y = -0.375;
            leftLegG.add(leftLeg); mesh.add(leftLegG);

            const rightLegG = new THREE.Group(); rightLegG.position.set(0.12, 0.5, 0);
            const rightLeg = new THREE.Mesh(legGeo, matPants); rightLeg.position.y = -0.375;
            rightLegG.add(rightLeg); mesh.add(rightLegG);

            mesh.userData.limbs = { la: leftArmG, ra: rightArmG, ll: leftLegG, rl: rightLegG };
            return mesh;
        }

        function updatePlayerAnim(mesh, dt, isMoving) {
            if(!mesh.userData.limbs) return;
            const { la, ra, ll, rl } = mesh.userData.limbs;
            if(isMoving) {
                const angle = Math.sin(Date.now() * 0.01) * 0.6;
                ll.rotation.x = angle; rl.rotation.x = -angle;
                la.rotation.x = -angle; ra.rotation.x = angle;
            } else {
                ll.rotation.x = ra.rotation.x = la.rotation.x = rl.rotation.x = 0;
            }
        }

        function init3D() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(50, 100, 50); dir.castShadow = true;
            dir.shadow.mapSize.width = 1024; dir.shadow.mapSize.height = 1024; scene.add(dir);

            const floorTex = createFloorTexture();
            const planeMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), planeMat);
            plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true;
            plane.userData = { isBlock: true, isFloor: true, key: 'floor' };
            scene.add(plane); blockObjects.push(plane);

            localPlayer = new THREE.Group(); localPlayer.position.set(0, 10, 0);
            myMeshBody = createPlayerMesh(true); localPlayer.add(myMeshBody);
            scene.add(localPlayer);

            const ghostGeo = new THREE.BoxGeometry(1, 1, 1);
            const ghostMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
            ghostMesh = new THREE.Mesh(ghostGeo, ghostMat); scene.add(ghostMesh);

            clock = new THREE.Clock();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        function setupNetwork() {
            channel = supabase.channel(state.room, { config: { presence: { key: state.id }, broadcast: { self: false } } });
            channel.on('presence', { event: 'sync' }, () => {
                const presences = channel.presenceState();
                for(let pid in remotePlayers) if(!presences[pid]) removeRemotePlayer(pid);
                for(let pid in presences) {
                    if(pid !== state.id && !remotePlayers[pid]) {
                        createRemotePlayer(pid, presences[pid][0].name);
                        if(presences[state.id] && presences[state.id][0].onlineAt < Date.now() - 2000) sendWorldChunk(pid);
                        sendBlockDefs(pid);
                    }
                }
            });
            channel.on('broadcast', { event: 'pos' }, ({ payload }) => {
                if(remotePlayers[payload.id]) {
                    const p = remotePlayers[payload.id];
                    p.targetPos.set(payload.x, payload.y, payload.z);
                    p.targetRot = payload.rot;
                }
            });
            channel.on('broadcast', { event: 'block' }, ({ payload }) => {
                if(payload.action === 'add') createBlock(payload.x, payload.y, payload.z, payload.type);
                else if(payload.action === 'remove') removeBlock(payload.x, payload.y, payload.z);
            });
            channel.on('broadcast', { event: 'chat' }, ({ payload }) => {
                app.addChatMessage(payload.name, payload.msg);
                if(remotePlayers[payload.id]) showBubble(remotePlayers[payload.id].mesh, payload.msg, payload.name);
            });
            channel.on('broadcast', { event: 'new_def' }, ({ payload }) => {
                if(!BLOCK_REGISTRY[payload.id]) {
                    BLOCK_REGISTRY[payload.id] = payload.def; createMaterial(payload.id, payload.def);
                    if(document.getElementById('modal-overlay').style.display === 'flex') app.updateInventoryUI();
                }
            });
            channel.on('broadcast', { event: 'world_sync' }, ({ payload }) => {
                if(payload.target === state.id) payload.blocks.forEach(b => createBlock(b.x, b.y, b.z, b.t));
            });
            channel.on('broadcast', { event: 'def_sync' }, ({ payload }) => {
                if(payload.target === state.id) {
                    payload.defs.forEach(d => { if(!BLOCK_REGISTRY[d.id]) { BLOCK_REGISTRY[d.id] = d.def; createMaterial(d.id, d.def); } });
                }
            });
            channel.on('broadcast', { event: 'req_sync' }, ({ payload }) => {
                if(payload.id !== state.id) { sendWorldChunk(payload.id); sendBlockDefs(payload.id); }
            });
            channel.subscribe(async (status) => {
                if(status === 'SUBSCRIBED') {
                    await channel.track({ name: state.name, onlineAt: Date.now() });
                    document.getElementById('loader').style.display = 'none'; document.getElementById('game-ui').style.display = 'block';
                    channel.send({ type: 'broadcast', event: 'req_sync', payload: { id: state.id } });
                }
            });
        }

        function sendWorldChunk(targetId) {
            const list = [];
            for(let key in blocksData) { const b = blocksData[key]; list.push({ x: b.mesh.position.x, y: b.mesh.position.y, z: b.mesh.position.z, t: b.type }); }
            if(list.length > 0) {
                const chunkSize = 50;
                for (let i = 0; i < list.length; i += chunkSize) {
                    channel.send({ type: 'broadcast', event: 'world_sync', payload: { target: targetId, blocks: list.slice(i, i + chunkSize) } });
                }
            }
        }
        function sendBlockDefs(targetId) {
            const list = [];
            for(let id in BLOCK_REGISTRY) { if(id.startsWith('c_')) list.push({ id: id, def: BLOCK_REGISTRY[id] }); }
            if(list.length > 0) channel.send({ type: 'broadcast', event: 'def_sync', payload: { target: targetId, defs: list } });
        }

        function createRemotePlayer(id, name) {
            const group = new THREE.Group(); const mesh = createPlayerMesh(false); group.add(mesh);
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0,0,256,64);
            ctx.fillStyle = "white"; ctx.font = "bold 40px Arial"; ctx.textAlign = "center";
            ctx.fillText(name, 128, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.position.y = 2.5; sprite.scale.set(2, 0.5, 1); group.add(sprite);
            scene.add(group);
            remotePlayers[id] = { mesh: group, bodyMesh: mesh, targetPos: new THREE.Vector3(0, 10, 0), targetRot: 0, lastPos: new THREE.Vector3(0,10,0), name: name };
            showBubble(group, "Entrou!", name);
        }
        function removeRemotePlayer(id) { if(remotePlayers[id]) { scene.remove(remotePlayers[id].mesh); delete remotePlayers[id]; } }

        function createBlock(x, y, z, type) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(blocksData[key]) return;
            if(!MATERIALS[type]) type = '1';
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geo, MATERIALS[type]);
            mesh.position.set(x, y, z); mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.userData = { isBlock: true, key: key };
            scene.add(mesh); blockObjects.push(mesh);
            
            // Inst√¢ncia do bloco com suporte a script
            const blockInstance = { type: type, mesh: mesh, props: BLOCK_REGISTRY[type].props, scriptText: BLOCK_REGISTRY[type].script, onTick: null, onPlace: null, onMine: null };
            blocksData[key] = blockInstance;

            // Executa script se existir
            if (blockInstance.scriptText) executeBlockScript(blockInstance, blockInstance.scriptText);
        }

        function removeBlock(x, y, z) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(blocksData[key]) {
                const mesh = blocksData[key].mesh; scene.remove(mesh);
                blockObjects = blockObjects.filter(o => o !== mesh); delete blocksData[key];
            }
        }
        function updateGhostMaterial() {
            if(ghostMesh && MATERIALS[selectedBlockId]) {
                ghostMesh.material.color.copy(MATERIALS[selectedBlockId].color);
                if(MATERIALS[selectedBlockId].emissive) ghostMesh.material.emissive.copy(MATERIALS[selectedBlockId].emissive);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            const now = Date.now();
            updateLocalPhysics(dt);
            const isMoving = (state.moveX !== 0 || state.moveY !== 0);
            updatePlayerAnim(myMeshBody, dt, isMoving);
            camera.position.copy(localPlayer.position); camera.position.y += 1.6;
            camera.rotation.order = 'YXZ'; camera.rotation.y = state.rotY; camera.rotation.x = state.rotX;
            myMeshBody.rotation.y = state.rotY;
            
            // Loop de Scripts
            for (let key in blocksData) {
                if (blocksData[key].onTick) blocksData[key].onTick();
            }

            if(channel && now - lastBroadcast > 66) {
                channel.send({ type: 'broadcast', event: 'pos', payload: { id: state.id, x: parseFloat(localPlayer.position.x.toFixed(2)), y: parseFloat(localPlayer.position.y.toFixed(2)), z: parseFloat(localPlayer.position.z.toFixed(2)), rot: parseFloat(state.rotY.toFixed(2)) } });
                lastBroadcast = now;
            }
            for(let id in remotePlayers) {
                const p = remotePlayers[id];
                p.mesh.position.lerp(p.targetPos, 10 * dt); p.bodyMesh.rotation.y = p.targetRot;
                const dist = p.mesh.position.distanceTo(p.lastPos); updatePlayerAnim(p.bodyMesh, dt, dist > 0.01); p.lastPos.copy(p.mesh.position);
            }
            updateRaycast(); renderer.render(scene, camera);
        }

        function updateLocalPhysics(dt) {
            const speed = 5;
            const dx = Math.cos(state.rotY) * state.moveX + Math.sin(state.rotY) * state.moveY;
            const dz = -Math.sin(state.rotY) * state.moveX + Math.cos(state.rotY) * state.moveY;
            if(!checkCol(localPlayer.position.x + dx * speed * dt, localPlayer.position.y, localPlayer.position.z)) { localPlayer.position.x += dx * speed * dt; }
            if(!checkCol(localPlayer.position.x, localPlayer.position.y, localPlayer.position.z + dz * speed * dt)) { localPlayer.position.z += dz * speed * dt; }
            
            state.velY -= 15 * dt; 
            const nextY = localPlayer.position.y + state.velY * dt;

            if(checkCol(localPlayer.position.x, nextY, localPlayer.position.z)) {
                if (state.velY < 0) {
                    const blockY = Math.floor(nextY);
                    localPlayer.position.y = blockY + 1.001; 
                    state.velY = 0;
                    state.onGround = true;
                    const bx = Math.floor(localPlayer.position.x); const bz = Math.floor(localPlayer.position.z);
                    const blk = blocksData[`${bx},${blockY},${bz}`];
                    if(blk && blk.props && blk.props.bounciness) { state.velY = 8; state.onGround = false; }
                } else {
                    state.velY = 0; 
                }
            } 
            else if (nextY <= 0) { localPlayer.position.y = 0; state.velY = 0; state.onGround = true; }
            else { localPlayer.position.y = nextY; state.onGround = false; }
        }

        // --- CORRE√á√ÉO 1: COLIS√ÉO APRIMORADA (Verifica Raio do Jogador) ---
        function checkCol(x, y, z) {
            // Verifica colis√£o considerando a largura do jogador (0.3 de raio)
            const radius = 0.3;
            const points = [
                {ox: 0, oz: 0},
                {ox: radius, oz: radius}, {ox: -radius, oz: radius},
                {ox: radius, oz: -radius}, {ox: -radius, oz: -radius}
            ];
            
            for(let p of points) {
                const bx = Math.floor(x + p.ox);
                const bz = Math.floor(z + p.oz);
                const by = Math.floor(y);
                const byHead = Math.floor(y + 1.5);
                
                // Verifica colis√£o com bloco OU se est√° abaixo do ch√£o
                if(blocksData[`${bx},${by},${bz}`] || blocksData[`${bx},${byHead},${bz}`]) {
                    return true;
                }
            }
            return false;
        }

        // --- CORRE√á√ÉO 2: IMPEDIR CONSTRU√á√ÉO DENTRO DO CH√ÉO ---
        function updateRaycast() {
            if(!localPlayer) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(blockObjects);
            if(intersects.length > 0 && intersects[0].distance < 6) {
                const i = intersects[0]; const p = i.point; const n = i.face.normal;
                if(currentTool === 'build') {
                    const target = new THREE.Vector3().copy(p).add(n.clone().multiplyScalar(0.5));
                    const tx = Math.floor(target.x) + 0.5; const ty = Math.floor(target.y) + 0.5; const tz = Math.floor(target.z) + 0.5;
                    
                    // AQUI EST√Å A CORRE√á√ÉO DO CH√ÉO:
                    if (ty < 0.5) { 
                        ghostMesh.visible = false; 
                        return; 
                    }

                    const playerPos = localPlayer.position;
                    const dx = Math.abs(tx - playerPos.x); const dz = Math.abs(tz - playerPos.z); const dy = ty - playerPos.y;
                    ghostMesh.position.set(tx, ty, tz); ghostMesh.visible = true;
                    if(dx < 0.8 && dz < 0.8 && dy > -1 && dy < 1.8) { ghostMesh.material.color.setHex(0xff0000); ghostMesh.userData.canPlace = false; }
                    else { if(MATERIALS[selectedBlockId]) ghostMesh.material.color.copy(MATERIALS[selectedBlockId].color); ghostMesh.userData.canPlace = true; }
                } else {
                    const target = new THREE.Vector3().copy(p).sub(n.clone().multiplyScalar(0.1));
                    const bx = Math.floor(target.x) + 0.5; const by = Math.floor(target.y) + 0.5; const bz = Math.floor(target.z) + 0.5;
                    if(by < 0.5) { ghostMesh.visible = false; return; }
                    ghostMesh.position.set(bx, by, bz); ghostMesh.visible = true; ghostMesh.material.color.setHex(0xff0000);
                    ghostMesh.userData.targetKey = `${Math.floor(bx)},${Math.floor(by)},${Math.floor(bz)}`;
                }
            } else { ghostMesh.visible = false; }
        }

        function startAction() {
            isTouchingAction = true;
            if(currentTool === 'build') {
                if(!ghostMesh.visible || ghostMesh.userData.canPlace === false) return;
                const x = ghostMesh.position.x; const y = ghostMesh.position.y; const z = ghostMesh.position.z;
                
                // Seguran√ßa extra
                if (y < 0.5) return;

                createBlock(x, y, z, selectedBlockId);
                channel.send({ type: 'broadcast', event: 'block', payload: { action: 'add', x, y, z, type: selectedBlockId } });
                if(myMeshBody.userData.limbs) { myMeshBody.userData.limbs.ra.rotation.x = -1; setTimeout(()=>myMeshBody.userData.limbs.ra.rotation.x = 0, 150); }
            } else {
                const intersect = updateRaycast();
                if(ghostMesh.visible && ghostMesh.userData.targetKey) {
                    const targetKey = ghostMesh.userData.targetKey; miningProgress = 0;
                    document.getElementById('mining-bar-container').style.display = 'block'; document.getElementById('mining-bar').style.width = '0%';
                    if(myMeshBody.userData.limbs) myMeshBody.userData.limbs.ra.rotation.x = -1.5;
                    miningInterval = setInterval(() => {
                        updateRaycast();
                        if(!ghostMesh.visible || ghostMesh.userData.targetKey !== targetKey || !isTouchingAction) { stopAction(); return; }
                        miningProgress += 15; document.getElementById('mining-bar').style.width = miningProgress + '%';
                        if(myMeshBody.userData.limbs) myMeshBody.userData.limbs.ra.rotation.x = -1.5 + Math.sin(Date.now() * 0.5) * 0.2;
                        if(miningProgress >= 100) {
                            const b = blocksData[targetKey];
                            if(b) {
                                removeBlock(b.mesh.position.x, b.mesh.position.y, b.mesh.position.z);
                                channel.send({ type: 'broadcast', event: 'block', payload: { action: 'remove', x:b.mesh.position.x, y:b.mesh.position.y, z:b.mesh.position.z } });
                            } stopAction();
                        }
                    }, 100);
                }
            }
        }
        function stopAction() {
            isTouchingAction = false; if(miningInterval) clearInterval(miningInterval); miningInterval = null;
            document.getElementById('mining-bar-container').style.display = 'none';
            if(myMeshBody && myMeshBody.userData.limbs) myMeshBody.userData.limbs.ra.rotation.x = 0;
        }

        function setupInputs() {
            const zone = document.getElementById('stick-zone'); const knob = document.getElementById('stick-knob');
            let jId = null, startX = 0, startY = 0;
            zone.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; jId = t.identifier; startX = t.clientX; startY = t.clientY; });
            zone.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === jId) {
                        const t = e.changedTouches[i];
                        let dx = t.clientX - startX, dy = t.clientY - startY; const dist = Math.sqrt(dx*dx + dy*dy);
                        if(dist > 50) { dx = (dx/dist)*50; dy = (dy/dist)*50; }
                        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        state.moveX = dx / 50; state.moveY = dy / 50;
                    }
                }
            });
            zone.addEventListener('touchend', e => { for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === jId) { jId = null; state.moveX = 0; state.moveY = 0; knob.style.transform = `translate(-50%, -50%)`; } } });

            const look = document.getElementById('look-zone');
            let lId = null, lastLX = 0, lastLY = 0;
            look.addEventListener('touchstart', e => { const t = e.changedTouches[0]; lId = t.identifier; lastLX = t.clientX; lastLY = t.clientY; });
            look.addEventListener('touchmove', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === lId) {
                        const t = e.changedTouches[i];
                        state.rotY -= (t.clientX - lastLX) * 0.005; state.rotX -= (t.clientY - lastLY) * 0.005;
                        state.rotX = Math.max(-1.5, Math.min(1.5, state.rotX));
                        lastLX = t.clientX; lastLY = t.clientY;
                    }
                }
            });
            look.addEventListener('touchend', () => lId = null);

            const btnAction = document.getElementById('btn-action');
            btnAction.addEventListener('touchstart', e => { e.preventDefault(); startAction(); btnAction.style.transform = "scale(0.9)"; });
            btnAction.addEventListener('touchend', e => { e.preventDefault(); stopAction(); btnAction.style.transform = "scale(1)"; });
            
            document.getElementById('btn-jump').addEventListener('touchstart', e => {
                e.preventDefault(); if(state.onGround) { state.velY = 7; state.onGround = false; }
            });
        }
        function showBubble(target, msg, name) {
            const div = document.createElement('div'); div.className = 'player-bubble'; div.innerHTML = `<span class="player-name">${name}</span>${msg}`;
            document.getElementById('bubbles-container').appendChild(div); div.style.display = 'block';
            const updatePos = () => {
                if(!div.isConnected) return;
                const pos = target.position ? target.position.clone() : target.clone();
                pos.y += 2.5; pos.project(camera);
                const x = (pos.x * .5 + .5) * window.innerWidth; const y = (pos.y * -.5 + .5) * window.innerHeight;
                if(pos.z < 1) { div.style.left = x + 'px'; div.style.top = y + 'px'; } else { div.style.display = 'none'; }
                requestAnimationFrame(updatePos);
            }; updatePos(); setTimeout(() => div.remove(), 4000);
        }
    </script>
</body>
</html>

